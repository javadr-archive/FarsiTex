<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML LANG="fa" DIR="rtl">
<HEAD>
<META HTTP-EQUIV="Content-Type" content="text/html; charset=utf-8">
<TITLE></TITLE>
<LINK REL=STYLESHEET HREF="http://ce.sharif.ac.ir/~ghodsi/archive/My%20Usefull%20Documents/TeX%20%20Good%20Utitities/FTX2HTM/SAMPLES/ARTICLE.MBK/ftx2htm.css"></HEAD>
<BODY>












<!--%%%%%%%%%%%%%%-->



<P>

<P>

<P>
<P>

<P>







<!--\def\appendixname{ضمايم‌}-->




<P>

<!--\setlength{@\topmargin@}{@-۵mm@}-->


<!--\date{}-->


<PRE>



</PRE><CENTER>


<BIG CLASS=xHuge><B></B>روش‌‌ها‌ى‌ ‌ارتباط‌ بين‌ پرد‌ازش‌‌ها در UNIX</BIG> 
<P>
<BIG CLASS=xLarge><B></B>محمد مهديان‌</BIG> 
<P>
<BIG CLASS=large></BIG> 
<P>
</CENTER>
<P><PRE>



</PRE>
<P><P CLASS=section>مقدمه‌</P>

يکى‌ ‌از مهمترين‌ مقوله‌‌ها‌ى‌ مطرح‌ در مورد سيستم‌‌ها‌ى‌
‌عاملى‌ که‌ در ‌آنها مفهوم‌ پرد‌ازش‌<A NAME="footref1"><SUP><A HREF="article.htm#footnote1">۱</A></SUP></A> وجود د‌ارد، برقر‌ار‌ى‌
‌ارتباط‌ بين‌ پرد‌ازشها<A NAME="footref2"><SUP><A HREF="article.htm#footnote2">۲</A></SUP></A> يا IPC ‌است‌. 
معمولا در سيستم‌‌ها‌ى‌ ‌عامل‌ مختلف‌، روشها‌ى‌ مختلفى‌ بر‌ا‌ى‌
‌اين‌ منظور وجود د‌ارد. 
در ‌اين‌ نوشتار سعى‌ د‌اريم‌ دو روش‌ ‌از روشها‌ى‌
برقر‌ار‌ى‌ ‌ارتباط‌ بين‌ پرد‌ازشها‌ى‌ مختلف‌ در سيستم‌ ‌عامل‌ UNIX ر‌ا
تشريح‌ کنيم‌.  نخست‌ نگا‌هى‌ د‌اريم‌ بر روشها‌ى‌ مختلف‌
IPC در UNIX. 
پس‌ ‌از ‌آن‌ ‌هر يک‌ ‌از دو روش‌
سمافور و حافظه‌‌ى‌ مشترک‌ ر‌ا به‌ طور جد‌اگانه‌ بررسى‌ خو‌ا‌هيم‌ کرد. 
<P><P CLASS=section><A NAME="lblMethods"><SUP><A HREF="article.htm#refMethods">Methods</A></SUP></A> روشها‌ى‌ ‌ارتباط‌ بين‌ پرد‌ازشها در UNIX </P>

روشها‌ى‌ مختلفى‌ بر‌ا‌ى‌ ‌ارتباط‌ بين‌ پرد‌ازشها در UNIX وجود
د‌ارد.  ‌اين‌ روشها ‌عبارتند ‌از:
<OL>


<LI>فرستادن‌ سيگنال‌:
در UNIX، ‌هر پرد‌ازشى‌ مى‌تو‌اند به‌ پرد‌ازشها‌ى‌ ديگر‌ى‌ که‌
مربوط‌ به‌ ‌همان‌ کاربر باشند، سيگنال‌ بفرستد.  ‌البته‌ بر‌ا‌ى‌ ‌اين‌
منظور بايد شماره‌ (PID) ‌آن‌ پرد‌ازش‌ ر‌ا د‌اشته‌ باشد. 
‌اين‌ کار با دستور kill صورت‌ مى‌گيرد.  ‌البته‌ ‌استفاده‌ ‌از ‌اين‌
روش‌ بر‌ا‌ى‌ فرستادن‌ ‌اطلا‌عات‌ بين‌ پرد‌ازشها چند‌ان‌ مناسب‌ نيست‌
و ‌از ‌آن‌ تنها بر‌ا‌ى‌ ‌اطلا‌ع‌ د‌ادن‌ يک‌ و‌اقعه‌ به‌ يک‌ پرد‌ازش‌
و يا فرستادن‌ پيغامى‌ بر‌ا‌ى‌ متوقف‌ کردن‌ يک‌ پرد‌ازش‌ ‌استفاده‌
مى‌شود. 
<P>
<LI>Pipe:
که‌ مانند يک‌ لوله‌ ‌است‌ که‌ يک‌ پرد‌ازش‌ مى‌تو‌اند ‌از يک‌ سر
‌آن‌ ‌اطلا‌عاتى‌ ر‌ا بفرستد و پرد‌ازش‌ ديگر ‌اطلا‌عات‌ ر‌ا ‌از سر ديگر
لوله‌ دريافت‌ مى‌کند. 
‌البته‌ Pipe تنها مى‌تو‌اند در مورد پرد‌ازشهايى‌ که‌ در يک‌
گروه‌ ‌از پرد‌ازشها باشند، يعنى‌ يا پدر و فرزند باشند،
و يا پدر مشترکى‌ د‌اشته‌ باشند، به‌ کار رود. 
<P>
<LI>FIFO:
مانند Pipe ‌است‌ و گا‌هى‌ ‌اوقات‌ لوله‌‌ى‌ ‌اسم‌د‌ار<A NAME="footref3"><SUP><A HREF="article.htm#footnote3">۳</A></SUP></A>
نيز خو‌انده‌ مى‌شود.  تنها تفاوت‌ ‌آن‌ با Pipe در ‌اين‌ ‌است‌ که‌
FIFO ‌ها مى‌تو‌انند بر‌ا‌ى‌ برقر‌ار‌ى‌ ‌ارتباط‌ بين‌ دو پرد‌ازش‌ که‌
متعلق‌ به‌ يک‌ گروه‌ ‌از پرد‌ازشها نباشند نيز به‌ کار رود. 
<P>
<LI>Message Queue:
مانند FIFO ‌است‌، با ‌اين‌ تفاوت‌ که‌ در مورد FIFO،
پرد‌ازشى‌ که‌ ‌اطلا‌عات‌ ر‌ا مى‌فرستد و پرد‌ازشى‌ که‌ ‌اطلا‌عات‌ ر‌ا
دريافت‌ مى‌کند، ‌هر دو بايد به‌ طور ‌همزمان‌ در سيستم‌ حضور د‌اشته‌
باشند؛ ولى‌ در روش‌ Message Queue، ممکن‌ ‌است‌ که‌ يک‌ پرد‌ازش‌ پيامهايى‌ ر‌ا
در يک‌ Message Queue بگذ‌ارد و بعد خودش‌ متوقف‌ شود، و پس‌ ‌از ‌آن‌ يک‌ پرد‌ازش‌
ديگر ‌اين‌ پيامها ر‌ا ‌از ‌آن‌ بخو‌اند. 
<P>
<LI>سمافور:
‌اين‌ روش‌ در سال‌ ۱۹۶۸ توسط‌ Dijkstra بر‌ا‌ى‌ ‌هما‌هنگ‌ساز‌ى‌ پرد‌ازشها پيشنهاد
شد.  در مورد ‌اين‌ روش‌ در بخش‌ <A NAME="refSem"><SUP><A HREF="article.htm#lblSem">Sem</A></SUP></A> بيشتر صحبت‌ خو‌ا‌هيم‌ کرد. 
<P>
<LI>حافظه‌ مشترک‌:
‌استفاده‌ ‌از حافظه‌ مشترک‌ يکى‌ ‌از بهترين‌ و کار‌اترين‌ روشها‌ى‌
‌انتقال‌ د‌اده‌ بين‌ دو پرد‌ازش‌ ‌است‌. 
در مورد ‌اين‌ روش‌ نيز در بخش‌ <A NAME="refShm"><SUP><A HREF="article.htm#lblShm">Shm</A></SUP></A> صحبت‌ خو‌ا‌هيم‌ کرد. 
<P>
<LI>‌استفاده‌ ‌از Socket ‌ها و TLI:
با ‌استفاده‌ ‌از ‌اين‌ روش‌ دو پرد‌ازش‌ که‌ بر رو‌ى‌ دو کامپيوتر
مختلف‌ در يک‌ شبکه‌ ‌اجر‌ا مى‌شوند نيز مى‌تو‌انند با ‌هم‌ ‌ارتباط‌ برقر‌ار
کنند. 
</OL>

<P>در بين‌ روشها‌ى‌ فوق‌، روشها‌ى‌ شماره‌ ۴، ۵، و ۶ به‌ روشها‌ى‌ IPC
در System V موسومند.  روشها‌ى‌ ۱ و ۲ تنها بر‌ا‌ى‌ ‌ارتباط‌ بين‌ دو
پرد‌ازش‌ که‌ متعلق‌ به‌ يک‌ کاربر ‌هستند به‌ کار مى‌روند و بقيه‌ روشها
مى‌تو‌انند بر‌ا‌ى‌ ‌ارتباط‌ بين‌ دو پرد‌ازش‌ که‌ متعلق‌ به‌ يک‌ کاربر نيستند
نيز به‌ کار روند.  در بين‌ ‌اين‌ روشها، ‌استفاده‌ ‌از سمافور بر‌ا‌ى‌
‌هما‌هنگ‌ کردن‌ دو پرد‌ازش‌ بدون‌ Busy Waiting و ‌استفاده‌ ‌از حافظه‌ مشترک‌
بر‌ا‌ى‌ ‌انتقال‌ مقد‌ار زياد د‌اده‌ بسيار معمول‌ ‌هستند.  ‌همين‌ طور
روش‌ ۷ نيز در طر‌احى‌ نرم‌‌افز‌ار‌ها‌ى‌ شبکه‌ بسيار ‌استفاده‌ مى‌شود. 
<P><P CLASS=section><A NAME="lbl"><SUP><A HREF="article.htm#ref"></A></SUP></A> ساختار‌ها‌ى‌ مشترک‌ </P>

روشها‌ى‌ IPC در Message Queue) System V، سمافور، و حافظه‌ مشترک‌)
شبا‌هتها‌ى‌ زياد‌ى‌ در زمينه‌ ‌اطلا‌عاتى‌ که‌ ‌هسته‌<A NAME="footref4"><SUP><A HREF="article.htm#footnote4">۴</A></SUP></A> سيستم‌ ‌عامل‌
در مورد ‌آنها نگهد‌ار‌ى‌ مى‌کند و فر‌اخو‌انى‌‌ها‌ى‌ سيستم‌ لازم‌ بر‌ا‌ى‌ دستيابى‌ به‌
‌آنها د‌ارند. 
در ‌اين‌ بخش‌ برخى‌ ‌از ساختار‌ها‌ى‌ مشترک‌ بين‌ ‌اين‌ روشها
ر‌ا بررسى‌ خو‌ا‌هيم‌ کرد. 
<P>‌هسته‌ UNIX ‌همان‌طور که‌ در مورد ‌هر فايل‌ ‌اطلا‌عاتى‌ ر‌ا نگهد‌ار‌ى‌
مى‌کند، در مورد ‌هر کانال‌ IPC (که‌ مى‌تو‌اند Message Queue، سمافور،
و يا حافظه‌ مشترک‌ باشد)
نيز ‌اطلا‌عات‌ زير ر‌ا نگه‌ مى‌د‌ارد. 

<DIV CLASS=english>
<P>

<PRE>
 struct ipc_perm {
         ushort uid;     /* owner's user id */
         ushort gid;     /* owner's group id */
         ushort cuid;    /* creator's user id */
         ushort cgid;    /* creator's group id */
         ushort mode;    /* access modes */
         ushort seq;     /* slot usage sequence number */
         key_t  key;     /* key */
 };
 </PRE>


<DIV CLASS=farsi>
<P>
<P>‌اين‌ ساختار در 
<CODE>&lt;sys/ipc.h&gt;</CODE>
تعريف‌ شده‌ ‌است‌. 
با ‌استفاده‌ ‌از دستور‌ها‌ى‌ 
<CODE>msgctl</CODE>
(در مورد Message Queue)،

<CODE>semctl</CODE>
(در مورد سمافور)، و 
<CODE>shmctl</CODE>
(در مورد حافظه‌ مشترک‌)
مى‌تو‌ان‌ به‌ ‌اين‌ ساختار دسترسى‌ پيد‌ا کرد و يا ‌آن‌ ر‌ا
تغيير د‌اد. 
<P>در بين‌ فيلد‌ها‌ى‌ ‌اين‌ ساختار، فيلد‌ى‌ به‌ نام‌ 
<CODE>key</CODE>

ديده‌ مى‌شود.  ‌ا‌هميت‌ ‌اين‌ فيلد بر‌ا‌ى‌ کانال‌‌ها‌ى‌ IPC، مانند
‌ا‌هميت‌ ‌اسم‌ بر‌ا‌ى‌ فايل‌ ‌است‌؛ 
‌همان‌طور که‌ ‌هر فايلى‌ با يک‌ ‌اسم‌ شناخته‌ مى‌شود،
‌هر کانال‌ IPC نيز با يک‌ کليد (
<CODE>key</CODE>
)
شناخته‌ مى‌شود.  کليد يک‌ ‌عدد صحيح‌ ۳۲ بيتى‌ ‌است‌ که‌ دو پرد‌ازش‌
که‌ مى‌خو‌ا‌هند ‌از طريق‌ يک‌ کانال‌ IPC مشترک‌ ‌ارتباط‌ د‌اشته‌
باشند، بايد ‌از قبل‌ رو‌ى‌ يک‌ کليد تو‌افق‌ کرده‌ باشند و ‌هر
دو‌ى‌ ‌آنها کانالى‌ با ‌آن‌ کليد مشخص‌ ر‌ا باز کنند. 
‌البته‌ ‌اين‌ مشکل‌ وجود د‌ارد که‌ در صورتى‌ که‌ پرد‌ازش‌ ديگر‌ى‌
نيز بخو‌ا‌هد يک‌ کانال‌ IPC با ‌همان‌ کليد بگيرد،
کار ‌اين‌ پرد‌ازشها با ‌هم‌ تد‌اخل‌ پيد‌ا خو‌ا‌هد کرد. 
<P>‌هر پرد‌ازش‌ مى‌تو‌اند در ‌هنگام‌ گرفتن‌ کانال‌ IPC،
مقد‌ار کليد ر‌ا بر‌ابر با 
<CODE>IPC_PRIVATE</CODE>
مشخص‌ کند. 
در ‌اين‌ صورت‌ يک‌ کانال‌ منحصر به‌ فرد بر‌ا‌ى‌ ‌اين‌ پرد‌ازش‌
‌ايجاد خو‌ا‌هد شد.  ‌البته‌ ‌اگر بخو‌ا‌هيم‌ ‌از ‌اين‌ کانال‌ بر‌ا‌ى‌
‌ارتباط‌ بين‌ دو پرد‌ازش‌ ‌استفاده‌ کنيم‌، بايد مشخصات‌
کانال‌ گرفته‌ شده‌ ر‌ا با ‌استفاده‌ ‌از روش‌ ديگر‌ى‌
به‌ پرد‌ازش‌ طرف‌ ‌ارتباط‌ ‌اطلا‌ع‌ د‌هيم‌. 
‌استفاده‌ ‌از ‌امکان‌ مشخص‌ کردن‌ کليد به‌ صورت‌ 
<CODE>IPC_PRIVATE</CODE>
،
به‌ خصوص‌ در مو‌ارد‌ى‌ کاربرد د‌ارد که‌ دو پرد‌ازشى‌ که‌
مى‌خو‌ا‌هند با ‌هم‌ ‌ارتباط‌ برقر‌ار کنند، پرد‌ازشهايى‌ باشند
که‌ در ‌اثر 
<CODE>fork</CODE>
کردن‌، ‌از يک‌ پرد‌ازش‌ ‌ايجاد شده‌ باشند. 
در ‌اين‌ صورت‌ کافى‌ ‌است‌ قبل‌ ‌از ‌انجام‌ ‌عمل‌ 
<CODE>fork</CODE>
، کانال‌
‌ارتباطى‌ با کليد 
<CODE>IPC_PRIVATE</CODE>
گرفته‌ شود و پس‌ ‌از 
<CODE>fork</CODE>
کردن‌،
دو پرد‌ازش‌ ‌از ‌آن‌ ‌استفاده‌ کنند. 
<P><P CLASS=section><A NAME="lblSem"><SUP><A HREF="article.htm#refSem">Sem</A></SUP></A> سمافور</P>

يک‌ سمافور مانند يک‌ متغير با مقد‌ار صحيح‌ ‌است‌ که‌
مى‌تو‌انيم‌ ‌عمليات‌ زير ر‌ا رو‌ى‌ ‌آن‌ ‌انجام‌ د‌هيم‌:
<UL>


<LI>مقد‌ار سمافور ر‌ا به‌ ميز‌ان‌ مشخصى‌ ‌افز‌ايش‌ د‌هيم‌. 

<LI>صبر کنيم‌ تا مقد‌ار سمافور بر‌ابر با صفر شود. 

<LI>صبر کنيم‌ تا مقد‌ار سمافور ‌از ميز‌ان‌ مشخصى‌ بيشتر يا مساو‌ى‌ شود و
سپس‌ ‌اين‌ مقد‌ار ر‌ا ‌از مقد‌ار سمافور کم‌ کنيم‌. 
</UL>

نکته‌ مهمى‌ که‌ در مورد ‌انجام‌ ‌اين‌ ‌عملها وجود د‌ارد ‌اين‌ ‌است‌
که‌ ‌اولا ‌اين‌ ‌عملها توسط‌ سيستم‌ ‌عامل‌ به‌ صورت‌ تقسيم‌ ناپذير (Atomic) ‌اجر‌ا
مى‌شوند و بنابر‌اين‌ مى‌تو‌انند بر‌ا‌ى‌ ‌هما‌هنگ‌ساز‌ى‌ دو پرد‌ازش‌ به‌ کار
روند.  ثانيا ‌اين‌ که‌ ‌عمل‌ صبر کردن‌ بر‌ا‌ى‌ يک‌ سمافور ‌از نو‌ع‌
Busy Waiting نيست‌ و بنابر‌اين‌ کار‌ايى‌ سيستم‌ ر‌ا پايين‌ نمى‌‌آورد؛ 
يعنى‌ سيستم‌ در ‌هنگامى‌ که‌ پرد‌ازشى‌ بر‌ا‌ى‌ يک‌ سمافور صبر کرده‌ ‌است‌،
کار پرد‌ازشها‌ى‌ ديگر ر‌ا ‌انجام‌ مى‌د‌هد و وقتى‌ صرف‌ ‌آن‌ پرد‌ازش‌ نمى‌کند. 
بر‌ا‌ى‌ درک‌ بهتر مفهوم‌ سمافور‌ها، مى‌تو‌انيد به‌ کتابها‌ى‌ مختلف‌
سيستم‌ ‌عامل‌ مر‌اجعه‌ کنيد. 
<P>در يونيکس‌، مى‌تو‌انيم‌ يک‌ مجمو‌عه‌ ‌از سمافور‌ها ر‌ا به‌ ‌عنو‌ان‌ يک‌ کانال‌
IPC (با يک‌ کليد) بگيريم‌ و بر رو‌ى‌ ‌همه‌ ‌آنها ‌عملياتى‌ ر‌ا ‌انجام‌ د‌هيم‌. 
بنابر‌اين‌ يک‌ سمافور در يونيکس‌، در  و‌اقع‌، مجمو‌عه‌‌ا‌ى‌ ‌از سمافور‌هاست‌. 
<P><P CLASS=subsection><A NAME="lblSemGet"><SUP><A HREF="article.htm#refSemGet">SemGet</A></SUP></A> گرفتن‌ سمافور</P>

گرفتن‌ يک‌ مجمو‌عه‌ سمافور با ‌استفاده‌ ‌از دستور 
<CODE>semget</CODE>
‌انجام‌ مى‌شود. 
شکل‌ ‌اين‌ دستور به‌ صورت‌ زير ‌است‌:

<DIV CLASS=english>
<P>

<PRE>
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/sem.h&gt;
 
 int semget(key_t key, int nsems, int flag);
 </PRE>


<DIV CLASS=farsi>
<P>
<P>در صورتى‌ که‌ ‌اشکالى‌ در گرفتن‌ سمافور وجود د‌اشته‌ باشد،

<CODE>semget</CODE>
مقد‌ار <I>-۱</I> و در صورتى‌ که‌ ‌اشکالى‌ وجود ند‌اشته‌ باشد،
يک‌ ‌عدد صحيح‌ مثبت‌ ر‌ا به‌ ‌عنو‌ان‌ شاخص‌ سمافور<A NAME="footref5"><SUP><A HREF="article.htm#footnote5">۵</A></SUP></A>
برمى‌گرد‌اند. 
<P>پار‌امتر‌ها‌ى‌ ‌اين‌ دستور به‌ ‌اين‌ صورت‌ ‌هستند:
<UL>


<LI>
<CODE>key</CODE>
کليد‌ى‌ ‌است‌ که‌ سمافور ر‌ا مشخص‌ مى‌کند.  در مورد کليد‌ها
در بخش‌ ۲ به‌ ‌اند‌ازه‌‌ى‌ کافى‌ صحبت‌ کرديم‌. 
<P>
<LI>
<CODE>nsems</CODE>
تعد‌اد سمافور‌ها‌ى‌ مجمو‌عه‌ ر‌ا مشخص‌ مى‌کند. 
<P>
<LI>
<CODE>flag</CODE>
‌اجازه‌‌ها‌ى‌ دستيابى‌ به‌ سمافور ر‌ا مشخص‌ مى‌کند و ‌همين‌
طور ‌اين‌ که‌ ‌آيا سمافور بر‌ا‌ى‌ ‌اولين‌ بار ‌ايجاد مى‌شود و يا
مى‌خو‌ا‌هيم‌ به‌ يک‌ سمافور که‌ قبلا ‌ايجاد شده‌ ‌است‌، دسترسى‌
پيد‌ا کنيم‌.  ۹ بيت‌ پايين‌ 
<CODE>flag</CODE>
، ‌اجازه‌‌ها‌ى‌ دستيابى‌ ر‌ا مشخص‌
مى‌کند (به‌ ‌همان‌ ترتيبى‌ که‌ در مورد ‌اجازه‌ دستيابى‌ به‌ فايلها
د‌اشتيم‌. ) مقد‌ار 
<CODE>flag</CODE>
ر‌ا مى‌تو‌ان‌ با ترکيب‌ ثابتهايى‌ که‌
در جدول‌ زير ‌آمده‌‌اند، ‌ايجاد کرد:

<DIV CLASS=english>
<P>
<I><CENTER>
<TABLE BORDER="1">
	<TR>
	<TD ALIGN="CENTER">

Numeric 
	<TD ALIGN="CENTER"> Symbolic 
	<TD ALIGN="CENTER"> Description 
	<TR>
	<TD ALIGN="CENTER"> 
0400 
	<TD ALIGN="CENTER"> 
<CODE>SEM_R</CODE>

	<TD ALIGN="CENTER"> Read by owner  
	<TR>
	<TD ALIGN="CENTER">
0200 
	<TD ALIGN="CENTER"> 
<CODE>SEM_A</CODE>

	<TD ALIGN="CENTER"> Alter by owner  
	<TR>
	<TD ALIGN="CENTER">
0040 
	<TD ALIGN="CENTER"> 
<CODE>SEM_R&gt;&gt;3</CODE>

	<TD ALIGN="CENTER"> Read by group  
	<TR>
	<TD ALIGN="CENTER">
0020 
	<TD ALIGN="CENTER"> 
<CODE>SEM_A&gt;&gt;3</CODE>

	<TD ALIGN="CENTER"> Alter by group  
	<TR>
	<TD ALIGN="CENTER">
0004 
	<TD ALIGN="CENTER"> 
<CODE>SEM_R&gt;&gt;6</CODE>

	<TD ALIGN="CENTER"> Read by world  
	<TR>
	<TD ALIGN="CENTER">
0002 
	<TD ALIGN="CENTER"> 
<CODE>SEM_A&gt;&gt;6</CODE>

	<TD ALIGN="CENTER"> Alter by world  
	<TR>
	<TD ALIGN="CENTER">  
</TABLE>
</CENTER></I>

<DIV CLASS=farsi>
<P>
<P>
<CODE>IPC_CREAT</CODE>
به‌ معنى‌ ‌اين‌ ‌است‌ که‌ مى‌خو‌ا‌هيم‌ در صورتى‌ که‌ سمافور وجود
ند‌اشت‌، ‌ايجاد شود.  در صورتى‌ که‌ ‌علاوه‌ بر 
<CODE>IPC_CREAT</CODE>
، 
<CODE>IPC_EXCL</CODE>
ر‌ا نيز
‌انتخاب‌ کرده‌ باشيم‌، يعنى‌ ‌اين‌ که‌ مى‌خو‌ا‌هيم‌ در صورتى‌ که‌ سمافور
وجود ند‌اشت‌ ‌ايجاد شود، ولى‌ در صورتى‌ که‌ وجود د‌اشت‌،

<CODE>semget</CODE>
با گرفتن‌ خطا خارج‌ شود. 
بر‌ا‌ى‌ محاسبه‌ مقد‌ار 
<CODE>flag</CODE>
، بايد مقادير مورد نظر ر‌ا ‌از جدول‌ بالا
‌انتخاب‌ کرده‌ و سپس‌ ‌آنها ر‌ا با ‌هم‌ OR کنيم‌. 
بر‌ا‌ى‌ مثال‌ ‌اگر 
<CODE>flag</CODE>
ر‌ا بر‌ابر با

<CODE>SEM_R|SEM_A|(SEM_R&gt;&gt;۶)|IPC_CREAT</CODE>

در نظر بگيريم‌، بدين‌ معنى‌ ‌است‌ که‌ مى‌خو‌ا‌هيم‌ سمافور‌ى‌ بگيريم‌
که‌ خودمان‌ بتو‌انيم‌ ‌آن‌ ر‌ا بخو‌انيم‌ و يا تغيير د‌هيم‌ و بقيه‌
تنها بتو‌انند ‌آن‌ ر‌ا بخو‌انند.  ‌همچنين‌ در صورتى‌ که‌ سمافور
وجود ند‌اشت‌، مى‌خو‌ا‌هيم‌ ‌ايجاد شود. 
</UL>

<P CLASS=subsection>‌عمليات‌ رو‌ى‌ سمافور</P>

‌عمليات‌ رو‌ى‌ سمافور‌ها با ‌استفاده‌ ‌از دستور 
<CODE>semop</CODE>
‌انجام‌
مى‌شود.  شکل‌ ‌اين‌ دستور به‌ ‌اين‌ صورت‌ ‌است‌:

<DIV CLASS=english>
<P>

<PRE>
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/sem.h&gt;
 
 int semop(int semid, struct sembuf *opsptr, unsigned int nops);
 </PRE>


<DIV CLASS=farsi>
<P>
<P>‌اين‌ تابع‌ در صورت‌ موفقيت‌ صفر و در صورت‌ ‌عدم‌ موفقيت‌
<I>-۱</I> برمى‌گرد‌اند.  پار‌امتر‌ها‌ى‌ ‌اين‌ دستور به‌ ‌اين‌ صورت‌ ‌هستند:
<UL>


<LI>
<CODE>semid</CODE>
شاخص‌ سمافور‌ى‌ ‌است‌ که‌ مى‌خو‌ا‌هيم‌ ‌عمليات‌ رو‌ى‌ ‌آن‌ ‌انجام‌
شود. 

<LI>
<CODE>opsptr</CODE>
‌اشاره‌گر‌ى‌ به‌ يک‌ ‌آر‌ايه‌ ‌از متغير‌هايى‌ ‌از نو‌ع‌ 
<CODE>sembuf</CODE>

‌است‌. 
تعد‌اد ‌عناصر ‌اين‌ ‌آر‌ايه‌ در پار‌امتر سوم‌ (
<CODE>nops</CODE>
)
مشخص‌ مى‌شود. 
</UL>

‌هر متغير ‌از نو‌ع‌ 
<CODE>sembuf</CODE>
، يک‌ ‌عمل‌ رو‌ى‌ يک‌ سمافور ر‌ا مشخص‌
مى‌کند و به‌ ‌اين‌ صورت‌ تعريف‌ مى‌شود. 
<P>
<DIV CLASS=english>
<P>

<PRE>
 struct sembuf {
         ushort  sem_num;        /* semaphore number */
         short   sem_op;         /* semaphore operation */
         short   sem_flg;        /* operation flag */
 };
 </PRE>


<DIV CLASS=farsi>
<P>
<P><UL>


<LI>
<CODE>sem_num</CODE>
شماره‌ يک‌ سمافور ‌از مجمو‌عه‌ ر‌ا مشخص‌ مى‌کند
که‌ مى‌خو‌ا‌هيم‌ ‌عمل‌ رو‌ى‌ ‌آن‌ ‌انجام‌ شود.  (به‌ ياد د‌اشته‌ باشيد
که‌ در بخش‌ پيش‌ گفتيم‌ که‌ ‌هر سمافور‌ى‌ که‌ با يک‌ شاخص‌ مشخص‌
مى‌شود، در و‌اقع‌ يک‌ مجمو‌عه‌ ‌از سمافور‌هاست‌. )
<P>
<LI>
<CODE>sem_op</CODE>
يک‌ ‌عمل‌ ر‌ا مشخص‌ مى‌کند.  به‌ ‌اين‌ صورت‌ که‌ ‌اگر مقد‌ار
‌آن‌ مثبت‌ باشد، يعنى‌ ‌عمل‌ مورد نظر ‌اضافه‌ کردن‌ ‌اين‌
مقد‌ار به‌ مقد‌ار سمافور مشخص‌ شده‌ ‌است‌.  ‌اگر مقد‌ار 
<CODE>sem_op</CODE>

صفر باشد، ‌عمل‌ مورد نظر صبر کردن‌ بر‌ا‌ى‌ صفر شدن‌ مقد‌ار
سمافور مورد نظر ‌است‌ و ‌اگر مقد‌ار ‌آن‌ منفى‌ باشد، يعنى‌
مى‌خو‌ا‌هيم‌ ‌آن‌ مقد‌ار ر‌ا ‌از مقد‌ار سمافور کم‌ کنيم‌. 
(و در صورتى‌ که‌ مقد‌ار سمافور ‌از قدر مطلق‌ ‌اين‌ مقد‌ار
کمتر بود صبر کنيم‌. )
<P>
<LI>
<CODE>sem_flg</CODE>
در شر‌ايط‌ ‌عاد‌ى‌ صفر ‌است‌.  ‌اگر مقد‌ار ‌آن‌ ر‌ا بر‌ابر با

<CODE>IPC_NOWAIT</CODE>
تعريف‌ کنيم‌، به‌ ‌اين‌ معنى‌ ‌است‌ که‌ مى‌خو‌ا‌هيم‌ بر‌ا‌ى‌ ‌اجر‌ا‌ى‌
‌عمل‌ صبر نکنيم‌ و ‌اگر صبر کردن‌ لازم‌ باشد (مثلا بخو‌ا‌هيم‌ ‌از
سمافور‌ى‌ که‌ مقد‌ار ‌آن‌ صفر ‌است‌، يکى‌ کم‌ کنيم‌)
با برگرد‌اندن‌ خطا ‌از 
<CODE>semop</CODE>
خارج‌ شويم‌.  ‌همين‌ طور با مشخص‌
کردن‌ 
<CODE>SEM_UNDO</CODE>
در 
<CODE>sem_flg</CODE>
، مى‌تو‌انيم‌ ‌از ‌امکان‌ Undo که‌ در بخشها‌ى‌ بعد
در مورد ‌آن‌ بحث‌ خو‌ا‌هيم‌ کرد ‌استفاده‌ کنيم‌. 
</UL>

<P CLASS=subsection>تغيير مقد‌ار و حذف‌ سمافور</P>

با ‌استفاده‌ ‌از دستور 
<CODE>semctl</CODE>
، مى‌تو‌ان‌ کار‌ها‌ى‌ مختلفى‌ ر‌ا بر رو‌ى‌
سمافور ‌انجام‌ د‌اد.  ‌اين‌ دستور به‌ شکل‌ زير ‌است‌:
<P>
<DIV CLASS=english>
<P>

<PRE>
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/sem.h&gt;
 
 int semctl(int semid, int semnum, int cmd, union semun arg);
 
 union semun {
      int             val;       /* used for SETVAL only */
      struct semid_ds *buff;     /* used for IPC_STAT and IPC_SET */
      ushort          *array;    /* used for GETALL &amp; SETALL */
 } arg;
 </PRE>


<DIV CLASS=farsi>
<P>
<P>در صورتى‌ که‌ مقد‌ار پار‌امتر 
<CODE>cmd</CODE>
، بر‌ابر با 
<CODE>IPC_RMID</CODE>
باشد،
بدين‌ معنى‌ ‌است‌ که‌ مى‌خو‌ا‌هيم‌ سمافور ر‌ا ‌از کل‌ سيستم‌ حذف‌ کنيم‌. 
در صورتى‌ که‌ ‌اين‌ مقد‌ار بر‌ابر با 
<CODE>GETVAL</CODE>
يا 
<CODE>SETVAL</CODE>
باشد،
يعنى‌ مى‌خو‌ا‌هيم‌ مقد‌ار سمافور ر‌ا بخو‌انيم‌ و يا ‌آن‌ ر‌ا تغيير
د‌هيم‌. 
در ‌هر صورت‌ 
<CODE>semid</CODE>
شاخص‌ سمافور‌ى‌ ‌است‌ که‌ مى‌خو‌ا‌هيم‌ کار بر رو‌ى‌
‌آن‌ ‌انجام‌ شود و 
<CODE>semnum</CODE>
شماره‌ سمافور‌ى‌ ‌از مجمو‌عه‌ ر‌ا مشخص‌ مى‌کند
که‌ مقد‌ار ‌آن‌ ر‌ا مى‌خو‌ا‌هيم‌ بخو‌انيم‌ يا تغيير د‌هيم‌. 
‌اگر بخو‌ا‌هيم‌ مقد‌ار‌ى‌ ر‌ا بخو‌انيم‌، مقد‌ار خو‌انده‌ شده‌
توسط‌ تابع‌ برگرد‌انده‌ مى‌شود و در صورتى‌ که‌ بخو‌ا‌هيم‌ مقد‌ار‌ى‌
ر‌ا تغيير د‌هيم‌ بايد مقد‌ار مورد نظر ر‌ا در 
<CODE>arg.val</CODE>

قر‌ار د‌هيم‌. 
<P>با ‌استفاده‌ ‌از ‌اين‌ دستور کار‌ها‌ى‌ ديگر‌ى‌ نيز مى‌تو‌ان‌ ‌انجام‌
د‌اد که‌ در ‌اينجا ‌آنها ر‌ا ذکر نمى‌کنيم‌. 
<P><P CLASS=subsection>‌امکان‌ UNDO</P>

‌همان‌طور که‌ مى‌د‌انيم‌، سمافور‌ها بيشتر بر‌ا‌ى‌ ‌هما‌هنگ‌ کردن‌ پرد‌ازشها
در دسترسى‌ به‌ يک‌ منبع‌ ‌اشتر‌اکى‌ ‌استفاده‌ مى‌شوند. 
بر‌ا‌ى‌ مثال‌ ‌همان‌گونه‌ که‌ در بخش‌ بعد خو‌ا‌هيد ديد، مى‌تو‌ان‌ ‌از سمافور
بر‌ا‌ى‌ قفل‌ کردن‌ يک‌ فايل‌ ‌استفاده‌ کرد. 
حالا ‌اگر به‌ ‌هر دليلى‌ (مثلا فشردن‌ کليد‌ها‌ى‌ Ctrl-C
و يا 
<CODE>kill</CODE>
شدن‌ توسط‌ پرد‌ازش‌ ديگر)
يک‌ پرد‌ازش‌ که‌ با ‌استفاده‌ ‌از سمافور يک‌ منبع‌ ر‌ا قفل‌
کرده‌ ‌است‌ متوقف‌ شود، بقيه‌ پرد‌ازشها که‌ منتظر ‌اين‌ ‌هستند
که‌ ‌آن‌ پرد‌ازش‌ قفل‌ ر‌ا ‌آز‌اد کند، ‌همگى‌ بر‌ا‌ى‌ ‌هميشه‌ منتظر
خو‌ا‌هند ماند!
<P>بر‌ا‌ى‌ رفع‌ ‌اين‌ مشکل‌، ‌امکانى‌ به‌ نام‌ ‌امکان‌ Undo در سمافور‌ها
قر‌ار د‌اده‌ شده‌ ‌است‌.  بدين‌ صورت‌ که‌ مى‌تو‌انيم‌ در دستور 
<CODE>semop</CODE>
،
برخى‌ ‌از ‌عمل‌‌ها ر‌ا با ‌امکان‌ 
<CODE>SEM_UNDO</CODE>
معرفى‌ کنيم‌. 
در صورتى‌ که‌ پرد‌ازشى‌ که‌ ‌اين‌ ‌عملها ر‌ا ‌انجام‌ مى‌د‌هد
متوقف‌ شود، سيستم‌ تمام‌ ‌اين‌ ‌عملها ر‌ا Undo مى‌کند؛
يعنى‌ در صورتى‌ که‌ ‌عمل‌، ‌اضافه‌ کردن‌ يک‌ مقد‌ار به‌ سمافور ‌است‌،
‌آن‌ مقد‌ار ‌از سمافور کم‌ مى‌شود و در صورتى‌ که‌ ‌عمل‌، کم‌ کردن‌ يک‌ مقد‌ار
‌است‌، ‌آن‌ مقد‌ار ‌اضافه‌ مى‌شود. 
<P>‌امکان‌ Undo ‌علاوه‌ بر مورد‌ى‌ که‌ ذکر شد، در تشخيص‌ متوقف‌ شدن‌ پرد‌ازشها
نيز کاربرد د‌ارد. 
بر‌ا‌ى‌ مثال‌ فرض‌ کنيد که‌ مى‌خو‌ا‌هيم‌ يک‌ باز‌ى‌ دو نفره‌ بنويسيم‌، به‌ طور‌ى‌
که‌ با خارج‌ شدن‌ ‌هر يک‌ ‌از طرفين‌ ‌از باز‌ى‌، طرف‌ ديگر نيز خارج‌ شود. 
بر‌ا‌ى‌ ‌اين‌ منظور ‌هر يک‌ ‌از طرفين‌ مى‌تو‌اند با 
<CODE>fork</CODE>
کردن‌، يک‌ پرد‌ازش‌
‌ايجاد کند که‌ تنها کار ‌آن‌، چک‌ کردن‌ ‌اين‌ ‌است‌ که‌ ‌آيا
طرف‌ مقابل‌ خارج‌ شده‌ ‌است‌ يا نه‌. 
بر‌ا‌ى‌ پياده‌ساز‌ى‌ ‌اين‌ پرد‌ازش‌، کافى‌ ‌است‌ ‌هر يک‌ ‌از طرفين‌ يک‌ سمافور
د‌اشته‌ باشد که‌ در ‌ابتد‌ا مقد‌ار ‌آن‌ ر‌ا با ‌امکان‌ Undo يکى‌ ‌اضافه‌
کند و ‌از ‌آن‌ به‌ بعد با ‌آن‌ کار‌ى‌ ند‌اشته‌ باشد. 
پرد‌ازشى‌ که‌ مى‌خو‌ا‌هد خارج‌ شدن‌ طرف‌ مقابل‌ ر‌ا تشخيص‌ د‌هد، کافى‌ ‌است‌
که‌ بر رو‌ى‌ ‌اين‌ سمافور صبر کند تا مقد‌ار ‌آن‌ صفر شود. 
در ‌اين‌ ‌هنگام‌ مى‌تو‌ان‌ نتيجه‌ گرفت‌ که‌ طرف‌ مقابل‌ خارج‌ شده‌ ‌است‌. 
<P><P CLASS=subsection>مثال‌</P>

فرض‌ کنيد چند پرد‌ازش‌ مى‌خو‌ا‌هند ‌از يک‌ فايل‌ ‌استفاده‌
کنند که‌ در ‌هر لحظه‌ نبايد بيشتر ‌از يکى‌ ‌از ‌آنها به‌ ‌آن‌
دسترسى‌ د‌اشته‌ باشد.  بنابر‌اين‌ لازم‌ ‌است‌ که‌ ‌اين‌ پرد‌ازشها ر‌ا
با ‌هم‌ ‌هما‌هنگ‌ کنيم‌.  بر‌ا‌ى‌ ‌اين‌ منظور، مى‌خو‌ا‌هيم‌ ‌از سمافور
‌استفاده‌ کنيم‌.  با توجه‌ به‌ مطالب‌ بخشها‌ى‌ گذشته‌، مى‌تو‌انيم‌ ‌اين‌
کار ر‌ا به‌ صورت‌ زير ‌انجام‌ د‌هيم‌. 
<P>در ‌ابتد‌ا‌ى‌ ‌هر يک‌ ‌از پرد‌ازشها، تعريفها‌ى‌ زير ر‌ا قر‌ار مى‌د‌هيم‌. 

<DIV CLASS=english>
<P>

<PRE>
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/sem.h&gt;
 
 #define SEMKEY 1234567L         /* key value for semaphore */
 #define PERMS  SEM_R|SEM_A|(SEM_R&gt;&gt;3)|(SEM_A&gt;&gt;3)|(SEM_R&gt;&gt;6)|(SEM_A&gt;&gt;6)  /* = 0666 */
 
 static struct sembuf op_lock[2] = {
         0, 0, 0,        /* wait for sem #0 to become 0 */
         0, 1, SEM_UNDO  /* then increment it by 1 */
 };
 
 static struct sembuf op_unlock[1] = {
         0, -1, (IPC_NOWAIT | SEM_UNDO)
 };
 
 int semid = -1;         /* semaphore id */
 </PRE>


<DIV CLASS=farsi>
<P>
<P>پس‌ ‌از ‌اين‌ در قسمتى‌ که‌ مى‌خو‌ا‌هيم‌ ‌از فايل‌ ‌استفاده‌ کنيم‌، کافى‌
‌است‌ تابع‌ 
<CODE>my_lock</CODE>
که‌ به‌ صورت‌ زير نوشته‌ شده‌ ‌است‌ ر‌ا فر‌اخو‌انى‌ کنيم‌. 

<DIV CLASS=english>
<P>

<PRE>
 my_lock()
 {
      if (semid &lt; 0)
           semid = semget(SEMKEY, 1, IPC_CREAT | PERMS);
      semop(semid, &amp;op_lock[0], 2);
 }
 </PRE>


<DIV CLASS=farsi>
<P>
<P>و پس‌ ‌از پايان‌ ‌استفاده‌ ‌از فايل‌، تابع‌ 
<CODE>my_unlock</CODE>
که‌ به‌ صورت‌
زير پياده‌ ساز‌ى‌ شده‌ ‌است‌، صد‌ا زده‌ مى‌شود. 
<P>
<DIV CLASS=english>
<P>

<PRE>
 my_unlock()
 {
      semop(semid, &amp;op_unlock[0], 1);
 }
 </PRE>


<DIV CLASS=farsi>
<P>
<P><P CLASS=section><A NAME="lblShm"><SUP><A HREF="article.htm#refShm">Shm</A></SUP></A> حافظه‌ مشترک‌</P>

وقتى‌ که‌ بخو‌ا‌هيم‌ مقد‌ار زياد‌ى‌ د‌اده‌ ر‌ا بين‌ دو پرد‌ازش‌
‌انتقال‌ د‌هيم‌، يکى‌ ‌از بهترين‌ روشها ‌استفاده‌ ‌از حافظه‌
مشترک‌ ‌است‌.  ‌استفاده‌ ‌از حافظه‌ مشترک‌ با‌عث‌ بالا رفتن‌ کار‌ايى‌
‌ارتباط‌ بين‌ پرد‌ازشها مى‌شود، چون‌ ديگر بر‌ا‌ى‌ ‌انتقال‌ د‌اده‌‌ها
‌احتياج‌ به‌ ‌هيچ‌ فر‌اخو‌انى‌ سيستم‌<A NAME="footref6"><SUP><A HREF="article.htm#footnote6">۶</A></SUP></A> ند‌ارد. 
<P>‌همچنين‌ در مو‌اقعى‌ که‌ بخو‌ا‌هيم‌ يک‌ د‌اده‌ ر‌ا به‌ چند پرد‌ازش‌
بد‌هيم‌، ‌استفاده‌ ‌از حافظه‌ مشترک‌ بهترين‌ ر‌اه‌ برقر‌ار‌ى‌ ‌ارتباط‌
‌است‌؛ چون‌ در تمام‌ روشها‌ى‌ ديگر، د‌اده‌ بين‌ دو پرد‌ازش‌
که‌ يکى‌ توليد کننده‌ د‌اده‌ و ديگر‌ى‌ مصرف‌ کننده‌ ‌است‌، ‌انتقال‌
مى‌يابد. 
<P>‌همچنين‌ ‌از نظر پياده‌ساز‌ى‌ برنامه‌‌ها  حافظه‌ مشترک‌ يکى‌ ‌از
ساده‌ترين‌ روشهاست‌، چون‌ بر‌ا‌ى‌ ‌انتقال‌ د‌اده‌‌ها، کافى‌ ‌است‌ که‌
‌آنها ر‌ا مانند متغير‌ها‌ى‌ ‌عاد‌ى‌، در حافظه‌ بنويسيم‌؛
‌البته‌ در بخش‌ مشخصى‌ ‌از حافظه‌ که‌ قبلا به‌ ‌عنو‌ان‌ حافظه‌ مشترک‌
گرفته‌ شده‌ ‌است‌. 
<P><P CLASS=subsection>گرفتن‌ حافظه‌ مشترک‌</P>

بر‌ا‌ى‌ گرفتن‌ حافظه‌ مشترک‌، ‌ابتد‌ا بايد ‌از دستور 
<CODE>shmget</CODE>

‌استفاده‌ کرد.  شکل‌ ‌اين‌ دستور به‌ صورت‌ زير ‌است‌:

<DIV CLASS=english>
<P>

<PRE>
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/shm.h&gt;
 
 int shmget(key_t key, int size, int shmflag);
 </PRE>


<DIV CLASS=farsi>
<P>
<P>‌اين‌ تابع‌، در صورت‌ موفقيت‌، شاخص‌ حافظه‌ مشترک‌ گرفته‌ شده‌
و در صورت‌ ‌عدم‌ موفقيت‌، ‌عدد <I>-۱</I> برمى‌گرد‌اند. 
پار‌امتر‌ها‌ى‌ 
<CODE>key</CODE>
و 
<CODE>shmflag</CODE>
مانند دستور 
<CODE>semget</CODE>

(بخش‌ <A NAME="refSemGet"><SUP><A HREF="article.htm#lblSemGet">SemGet</A></SUP></A>) ‌هستند و پار‌امتر 
<CODE>size</CODE>
، تعد‌اد بايت‌‌ها‌ى‌
قطعه‌ حافظه‌ مشترک‌ مورد نياز ر‌ا مشخص‌ مى‌کند. 
دقت‌ کنيد که‌ مقد‌ار 
<CODE>size</CODE>
نمى‌تو‌اند ‌از حد مشخصى‌ بيشتر
باشد که‌ ‌اين‌ حد در ‌هر سيستم‌ مقد‌ار ثابت‌ و مشخصى‌ ‌است‌. 
<P>پس‌ ‌از ‌اين‌ که‌ با ‌استفاده‌ ‌از 
<CODE>shmget</CODE>
، يک‌ قطعه‌ حافظه‌ مشترک‌ گرفتيم‌،
بايد يک‌ ‌آدرس‌ ر‌ا به‌ ‌آن‌ منسوب‌ کنيم‌ تا ‌از ‌اين‌ به‌ بعد بتو‌انيم‌
د‌اده‌‌ها‌ى‌ مشترک‌  ر‌ا در ‌آن‌ ‌آدرس‌ بنويسيم‌.  بر‌ا‌ى‌ ‌اين‌ منظور ‌از دستور

<CODE>shmat</CODE>
‌استفاده‌ مى‌کنيم‌.  شکل‌ ‌اين‌ دستور به‌ صورت‌ زير ‌است‌:

<DIV CLASS=english>
<P>

<PRE>
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/shm.h&gt;
 
 int shmat(int shmid, char *shmaddr, int shmflag);
 </PRE>


<DIV CLASS=farsi>
<P>
<P>مقد‌ار برگشتى‌ توسط‌ ‌اين‌ تابع‌، ‌آدرس‌ قطعه‌ حافظه‌ مشترک‌ که‌
شاخص‌ ‌آن‌ بر‌ابر با 
<CODE>shmid</CODE>
‌است‌ ر‌ا مشخص‌ مى‌کند. 
پار‌امتر‌ها‌ى‌ 
<CODE>shmaddr</CODE>
و 
<CODE>shmflag</CODE>
بر‌ا‌ى‌ وقتى‌ به‌ کار مى‌روند که‌ بخو‌ا‌هيم‌
حافظه‌ مشترک‌ ر‌ا در يک‌ ‌آدرس‌ مشخص‌ بچسبانيم‌.  ‌البته‌ ‌اين‌ کار
در ‌همه‌ نسخه‌‌ها‌ى‌ يونيکس‌ ممکن‌ نيست‌ و بنابر‌اين‌ ما در ‌اينجا
در مورد ‌اين‌ ‌امکان‌ صحبت‌ نمى‌کنيم‌.  در حالت‌ ‌عاد‌ى‌، کافى‌ ‌است‌
مقد‌ار پار‌امتر‌ها‌ى‌ 
<CODE>shmaddr</CODE>
و 
<CODE>shmflag</CODE>
ر‌ا مساو‌ى‌ با صفر قر‌ار د‌هيم‌. 
<P>پس‌ ‌از گرفتن‌ ‌آدرس‌ حافظه‌ مشترک‌، مى‌تو‌ان‌ مانند ‌آدرسها‌ى‌
ديگر‌ى‌ که‌ برنامه‌ با دستور 
<CODE>malloc</CODE>
مى‌گيرد و ‌از ‌آنها ‌استفاده‌
مى‌کند، ‌از حافظه‌ مشترک‌ ‌استفاده‌ کرد. 
<P><P CLASS=subsection>حذف‌ حافظه‌ مشترک‌</P>

بر‌ا‌ى‌ حذف‌ يک‌ قطعه‌ حافظه‌ مشترک‌، بايد ‌ابتد‌ا ‌آدرس‌ نسبت‌ د‌اده‌ شده‌
به‌ ‌آن‌ ر‌ا با ‌استفاده‌ ‌از دستور 
<CODE>shmdt</CODE>
‌از بين‌ ببريم‌.  شکل‌ ‌اين‌ دستور
به‌ ‌اين‌ صورت‌ ‌است‌:

<DIV CLASS=english>
<P>

<PRE>
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/shm.h&gt;
 
 int shmdt(char *shmaddr);
 </PRE>


<DIV CLASS=farsi>
<P>
<P>پس‌ ‌از ‌اين‌، بايد با ‌استفاده‌ ‌از دستور 
<CODE>shmctl</CODE>
، قطعه‌ حافظه‌
مشترک‌ ر‌ا حذف‌ کنيم‌.  شکل‌ کلى‌ ‌اين‌ دستور به‌ ‌اين‌ صورت‌ ‌است‌:

<DIV CLASS=english>
<P>

<PRE>
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/shm.h&gt;
 
 int shmctl(int shmid, int cmd, struct shmid_ds *buf);
 </PRE>


<DIV CLASS=farsi>
<P>
<P>بر‌ا‌ى‌ حذف‌ حافظه‌ مشترک‌، بايد مقد‌ار پار‌امتر 
<CODE>cmd</CODE>
ر‌ا بر‌ابر با 
<CODE>IPC_RMID</CODE>

تعيين‌ کنيم‌.  پار‌امتر 
<CODE>buf</CODE>
بر‌ا‌ى‌ حذف‌ حافظه‌ مشترک‌ به‌ کار
نمى‌رود.  بنابر‌اين‌ مى‌تو‌انيم‌ مقد‌ار ‌آن‌ ر‌ا بر‌ابر با صفر
قر‌ار د‌هيم‌. 
<P>‌البته‌ دستور 
<CODE>shmctl</CODE>
کار‌ها‌ى‌ ديگر‌ى‌ نيز ‌انجام‌
مى‌د‌هد که‌ معمولا به‌ ‌آنها ‌احتياجى‌ ند‌اريم‌ و بنابر‌اين‌
در ‌اينجا ‌از ذکر ‌آنها صرف‌نظر مى‌کنيم‌. 
<P><P CLASS=subsection>مثال‌</P>

فرض‌ کنيد که‌ دو پرد‌ازش‌ د‌اريم‌ که‌ يکى‌ ‌از ‌آنها ‌اطلا‌عاتى‌ ر‌ا
بر‌ا‌ى‌ ديگر‌ى‌ توليد مى‌کند و ديگر‌ى‌ ‌از ‌اين‌ ‌اطلا‌عات‌ ‌استفاده‌
مى‌کند.  پرد‌ازش‌ ‌اولى‌ ر‌ا Server و دومى‌ ر‌ا Client مى‌ناميم‌. 
بر‌ا‌ى‌ پياده‌ساز‌ى‌ ‌اين‌ پرد‌ازشها، مى‌تو‌انيم‌ ‌از حافظه‌
مشترک‌ و سمافور ‌استفاده‌ کنيم‌. 
بدين‌ صورت‌ که‌ يک‌ قطعه‌ حافظه‌ مشترک‌ بر‌ا‌ى‌ ‌انتقال‌ ‌اطلا‌عات‌
بين‌ پرد‌ازشها مى‌گيريم‌ و ‌از يک‌ سمافور نيز بر‌ا‌ى‌ ‌هما‌هنگ‌ کردن‌
‌آنها ‌استفاده‌ مى‌کنيم‌. 
بر‌ا‌ى‌ ‌اين‌ منظور فرض‌ مى‌کنيم‌ که‌ مثبت‌ بودن‌ مقد‌ار سمافور به‌ معنى‌
‌آماده‌ بودن‌ ‌اطلا‌عات‌ مورد نياز بر‌ا‌ى‌ Client و صفر بودن‌ ‌آن‌ به‌ ‌اين‌
معنى‌ ‌است‌ که‌ Client منتظر ‌اطلا‌عات‌ جديد‌ى‌ ‌از طرف‌ Server ‌است‌. 
<P>برنامه‌ Server ر‌ا مى‌تو‌انيم‌ به‌ صورت‌ زير پياده‌ساز‌ى‌ کنيم‌. 

<DIV CLASS=english>
<P>


<PRE>
 /*
  *      Server
  */
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/shm.h&gt;
 #include &lt;sys/sem.h&gt;
 
 #define SEMKEY 1234567L         /* key value for semaphore */
 #define SHMKEY 1234567L         /* key value for shared memory */
 #define PERMS  0666
 
 static struct sembuf inc2[1] = {0, 2, 0};
 static struct sembuf wait0[1] = {0, 0, 0};
 
 int shmid, semid;
 char *a;
 
 main()
 {
   if (semid = semget(SEMKEY, 1, IPC_CREAT | PERMS)) &lt; 0) {
     printf(&quot; Error in semget.\n&quot;);
     exit(-1);
   }
 
   if (shmid = shmget(SHMKEY, 100, IPC_CREAT | PERMS) &lt; 0) {
     printf(&quot; Error in shmget.\n&quot;);
     exit(-1);
   }
   a = shmat(shmid, 0, 0);
 
   while (1) {
     gen_data(a);
     semop(semid, inc2, 1);      /* increment the semaphore value by 2 */
     semop(semid, wait0, 1);     /* wait for the semaphore to become 0 */
   }
 
   if (shmdt(a) &lt; 0) {
     printf(&quot; Error in shmdt.\n&quot;);
     exit(-1);
   }
   if (shmctl(shmid, IPC_RMID, 0) &lt; 0) {
     printf(&quot; Error in shmctl.\n&quot;);
     exit(-1);
   }
   if (semctl(semid, IPC_RMID, 0) &lt; 0) {
     printf(&quot; Error in semctl.\n&quot;);
     exit(-1);
   }
 }
 </PRE>



<DIV CLASS=farsi>
<P>
<P>برنامه‌ Client ر‌ا مى‌تو‌انيم‌ به‌ صورت‌ زير پياده‌ساز‌ى‌ کنيم‌. 

<DIV CLASS=english>
<P>


<PRE>
 /*
  *      Client
  */
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/shm.h&gt;
 #include &lt;sys/sem.h&gt;
 
 #define SEMKEY 1234567L         /* key value for semaphore */
 #define SHMKEY 1234567L         /* key value for shared memory */
 #define PERMS  0666
 
 static struct sembuf dec1[1] = {0, 1, 0};
 
 int shmid, semid;
 char *a;
 
 main()
 {
   if (semid = semget(SEMKEY, 1, IPC_CREAT | PERMS)) &lt; 0) {
     printf(&quot; Error in semget.\n&quot;);
     exit(-1);
   }
 
   if (shmid = shmget(SHMKEY, 100, IPC_CREAT | PERMS) &lt; 0) {
     printf(&quot; Error in shmget.\n&quot;);
     exit(-1);
   }
   a = shmat(shmid, 0, 0);
 
   while (1) {
     semop(semid, dec1, 1);      /* wait until the semaphore value become
                                    positive, then decrement it by 1 */
     consume_data(a);
     semop(semid, dec1, 1);      /* decrement the semaphore value by 1 */
   }
 
   if (shmdt(a) &lt; 0) {
     printf(&quot; Error in shmdt.\n&quot;);
     exit(-1);
   }
   if (shmctl(shmid, IPC_RMID, 0) &lt; 0) {
     printf(&quot; Error in shmctl.\n&quot;);
     exit(-1);
   }
   if (semctl(semid, IPC_RMID, 0) &lt; 0) {
     printf(&quot; Error in semctl.\n&quot;);
     exit(-1);
   }
 }
 </PRE>



<DIV CLASS=farsi>
<P>
<P>در برنامه‌ Server، 
<CODE>gen_data(a)</CODE>
تابعى‌ ‌است‌ که‌ ‌اطلا‌عات‌ مورد نياز
ر‌ا توليد مى‌کند
و ‌آنها ر‌ا در ‌آدرس‌ 
<CODE>a</CODE>
مى‌نويسد. 
‌همچنين‌ در برنامه‌ Client، 
<CODE>consume_data(a)</CODE>
تابعى‌ ‌است‌ که‌
‌اطلا‌عات‌ موجود در ‌آدرس‌ 
<CODE>a</CODE>
ر‌ا مورد ‌استفاده‌ قر‌ار مى‌د‌هد. 
<P>قبل‌ ‌از صد‌ا کردن‌ 
<CODE>consume_data(a)</CODE>
، يکى‌ ‌از مقد‌ار سمافور کم‌ مى‌کنيم‌. 
نتيجه‌ ‌اين‌ ‌عمل‌ ‌اين‌ ‌است‌ که‌ تا ‌هنگامى‌ که‌ ‌اطلا‌عات‌ مورد نياز
توسط‌ Server فر‌ا‌هم‌ نشده‌ ‌است‌ و مقد‌ار سمافور صفر ‌است‌، صبر خو‌ا‌هيم‌
کرد و پس‌ ‌از ‌آن‌ که‌ ‌اين‌ ‌اطلا‌عات‌ توسط‌ Server فر‌ا‌هم‌ شد و
Server ‌از تابع‌ 
<CODE>gen_data(a)</CODE>
خارج‌ شد، مقد‌ار سمافور ر‌ا به‌ ۲
‌افز‌ايش‌ مى‌د‌هد و در نتيجه‌ Client مى‌تو‌اند و‌ارد 
<CODE>consume_data(a)</CODE>

شود.  پس‌ ‌از ‌اين‌ که‌ Client ‌از ‌اين‌ تابع‌ خارج‌ شد،
بايد به‌ Server ‌اطلا‌ع‌ د‌هد که‌ ‌اطلا‌عات‌ توليد شده‌، مصرف‌
شده‌ ‌است‌ و نياز به‌ ‌اطلا‌عات‌ جديد د‌ارد.  ‌اين‌ کار ر‌ا با
يکى‌ کم‌ کردن‌ مقد‌ار سمافور که‌ در نتيجه‌ مقد‌ار ‌آن‌ ر‌ا به‌
صفر مى‌رساند، ‌انجام‌ مى‌د‌هيم‌.  پس‌ ‌از ‌اين‌ Server متوجه‌ مى‌شود
که‌ ‌اطلا‌عات‌ جديد مورد نياز ‌است‌.  بنابر‌اين‌ دوباره‌ و‌ارد
تابع‌ 
<CODE>gen_data(a)</CODE>
مى‌شود و ‌اين‌ ‌اطلا‌عات‌ ر‌ا توليد مى‌کند. 
<P>در صورتى‌ که‌ به‌ جا‌ى‌ يک‌ Client، چند Client د‌اشته‌ باشيم‌ نيز مى‌تو‌انيم‌
‌از برنامه‌‌ا‌ى‌ مشابه‌ با برنامه‌ فوق‌ ‌استفاده‌ کنيم‌.  تنها کافى‌ ‌است‌
بر‌ا‌ى‌ ‌هر يک‌ ‌از Client ‌ها، يک‌ سمافور جد‌اگانه‌ تخصيص‌ د‌هيم‌. 
<P><P CLASS=section>خلاصه‌</P>

در ‌اين‌ مقاله‌ ديديم‌ که‌ در يونيکس‌ چگونه‌ مى‌تو‌ان‌ با ‌استفاده‌ ‌از سمافور‌ها و
حافظه‌ مشترک‌، بين‌ دو پرد‌ازش‌ ‌ارتباط‌ برقر‌ار کرد.  يعنى‌
‌آنها ر‌ا با ‌هم‌ ‌هما‌هنگ‌ کرد و ‌اطلا‌عاتى‌ ر‌ا بين‌ ‌آنها ‌انتقال‌ د‌اد. 
‌استفاده‌ ‌از ‌اين‌ روشها، کار‌اترين‌ ر‌اه‌ بر‌ا‌ى‌ ‌ارتباط‌ بين‌ چند
پرد‌ازش‌ در يونيکس‌ ‌است‌. 
بر‌ا‌ى‌ ‌استفاده‌ ‌از سمافور، سه‌ دستور 
<CODE>semget</CODE>
،

<CODE>semop</CODE>
، و 
<CODE>shmctl</CODE>
،
و بر‌ا‌ى‌ ‌استفاده‌ ‌از حافظه‌ مشترک‌ چهار دستور 
<CODE>shmget</CODE>
،

<CODE>shmat</CODE>
، 
<CODE>shmdt</CODE>
، و 
<CODE>shmctl</CODE>
ر‌ا معرفى‌ کرديم‌. 
‌اين‌ دستور‌ها تمام‌ کار‌ها‌ى‌ ‌اوليه‌ ر‌ا ‌انجام‌ مى‌د‌هند و
با ‌استفاده‌ ‌از ‌آنها مى‌تو‌ان‌ برنامه‌‌ها‌ى‌ بسيار‌ى‌ بر رو‌ى‌ سيستم‌
‌عامل‌ يونيکس‌ نوشت‌. 
<P>
<P CLASS=thebibliography>مر‌اجع‌</P>

<OL>


<DIV CLASS=english>
<P>

<LI><A NAME="bibunix"><SUP><A HREF="article.htm#citunix">unix</A></SUP></A>W. &nbsp;Richard&nbsp;Stevens, <EM>UNIX Network Programming</EM>,
Prentice Hall, 1990. 
</OL>



<HR>
<BR>
<A NAME="footnote1"><SUP><A HREF="article.htm#footref1">۱</A></SUP></A>Process<BR>
<A NAME="footnote2"><SUP><A HREF="article.htm#footref2">۲</A></SUP></A>Interprocess Communication<BR>
<A NAME="footnote3"><SUP><A HREF="article.htm#footref3">۳</A></SUP></A>Named Pipe<BR>
<A NAME="footnote4"><SUP><A HREF="article.htm#footref4">۴</A></SUP></A>Kernel<BR>
<A NAME="footnote5"><SUP><A HREF="article.htm#footref5">۵</A></SUP></A>Semaphore Identifier<BR>
<A NAME="footnote6"><SUP><A HREF="article.htm#footref6">۶</A></SUP></A>System Call</BODY>
</HTML>
<br><center><font size="1">This file was downloaded with an evaluation copy of <a href="http://www.sparkleware.com/superbot/watermark/">SuperBot</a>. This message is not added by licensed copies of <a href="http://www.sparkleware.com/superbot/watermark/">SuperBot</a>.</font></center>